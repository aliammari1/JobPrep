generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

model User {
  id                  String                @id
  name                String
  email               String                @unique
  emailVerified       Boolean               @default(false)
  image               String?
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @default(now()) @updatedAt
  username            String?               @unique
  displayUsername     String?
  twoFactorEnabled    Boolean?              @default(false)
  role                String?
  banned              Boolean?              @default(false)
  banReason           String?
  banExpires          DateTime?
  phoneNumber         String?               @unique
  phoneNumberVerified Boolean?
  accounts            Account[]
  aiMockSessions      AIMockSession[]       @relation("AIMockSessions")
  candidateProfile    CandidateProfile?     @relation("CandidateProfile")
  candidateInterviews Interview[]           @relation("CandidateInterviews")
  interviewerSessions Interview[]           @relation("InterviewerSessions")
  evaluations         InterviewEvaluation[] @relation("EvaluatorAssessments")
  createdTemplates    InterviewTemplate[]   @relation("CreatedTemplates")
  invitations         Invitation[]
  members             Member[]
  passkeys            Passkey[]
  sessions            Session[]
  twofactors          TwoFactor[]

  @@map("user")
}

model Session {
  id                   String   @id
  expiresAt            DateTime
  token                String   @unique
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  ipAddress            String?
  userAgent            String?
  userId               String
  impersonatedBy       String?
  activeOrganizationId String?
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

model TwoFactor {
  id          String @id
  secret      String
  backupCodes String
  userId      String
  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("twoFactor")
}

model Organization {
  id          String       @id
  name        String
  slug        String       @unique
  logo        String?
  createdAt   DateTime
  metadata    String?
  invitations Invitation[]
  members     Member[]

  @@map("organization")
}

model Member {
  id             String       @id
  organizationId String
  userId         String
  role           String
  createdAt      DateTime
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("member")
}

model Invitation {
  id             String       @id
  organizationId String
  email          String
  role           String?
  status         String
  expiresAt      DateTime
  inviterId      String
  user           User         @relation(fields: [inviterId], references: [id], onDelete: Cascade)
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@map("invitation")
}

model Passkey {
  id           String    @id
  name         String?
  publicKey    String
  userId       String
  credentialID String
  counter      Int
  deviceType   String
  backedUp     Boolean
  transports   String?
  createdAt    DateTime?
  aaguid       String?
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("passkey")
}

model InterviewTemplate {
  id          String              @id @default(cuid())
  title       String
  description String?
  category    String
  difficulty  String
  duration    Int
  isPublic    Boolean             @default(false)
  createdBy   String
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  tags        String[]
  interviews  Interview[]
  questions   InterviewQuestion[]
  creator     User                @relation("CreatedTemplates", fields: [createdBy], references: [id], onDelete: Cascade)

  @@map("interview_template")
}

model InterviewQuestion {
  id                 String              @id @default(cuid())
  templateId         String
  question           String
  questionType       String
  difficulty         String
  expectedAnswer     String?
  timeLimit          Int?
  codeLanguages      String[]
  evaluationCriteria String?
  order              Int
  createdAt          DateTime            @default(now())
  template           InterviewTemplate   @relation(fields: [templateId], references: [id], onDelete: Cascade)
  responses          InterviewResponse[]

  @@map("interview_question")
}

model Interview {
  id                 String                @id @default(cuid())
  candidateId        String
  interviewerId      String?
  templateId         String
  status             String                @default("scheduled")
  scheduledAt        DateTime?
  startedAt          DateTime?
  completedAt        DateTime?
  duration           Int?
  videoRecordingUrl  String?
  audioRecordingUrl  String?
  aiAnalysisReport   String?
  overallScore       Float?
  technicalScore     Float?
  behavioralScore    Float?
  communicationScore Float?
  isAIInterviewer    Boolean               @default(false)
  allowRecording     Boolean               @default(true)
  settings           String?
  createdAt          DateTime              @default(now())
  updatedAt          DateTime              @updatedAt
  candidateEmail     String?
  candidateName      String?
  candidatePhone     String?
  isCalendarSynced   Boolean               @default(false)
  location           String?
  notes              String?
  position           String?
  reminderSent       Boolean               @default(false)
  time               String?
  type               String                @default("video")
  candidate          User                  @relation("CandidateInterviews", fields: [candidateId], references: [id], onDelete: Cascade)
  interviewer        User?                 @relation("InterviewerSessions", fields: [interviewerId], references: [id])
  template           InterviewTemplate     @relation(fields: [templateId], references: [id], onDelete: Cascade)
  analytics          InterviewAnalytics[]
  evaluations        InterviewEvaluation[]
  responses          InterviewResponse[]

  @@map("interview")
}

model InterviewResponse {
  id           String            @id @default(cuid())
  interviewId  String
  questionId   String
  responseText String?
  codeResponse String?
  language     String?
  timeSpent    Int?
  startedAt    DateTime?
  submittedAt  DateTime?
  aiScore      Float?
  aiFeedback   String?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  interview    Interview         @relation(fields: [interviewId], references: [id], onDelete: Cascade)
  question     InterviewQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@map("interview_response")
}

model InterviewEvaluation {
  id                 String    @id @default(cuid())
  interviewId        String
  evaluatorId        String
  technicalScore     Float?
  behavioralScore    Float?
  communicationScore Float?
  overallScore       Float?
  strengths          String?
  improvements       String?
  recommendation     String?
  notes              String?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  evaluator          User      @relation("EvaluatorAssessments", fields: [evaluatorId], references: [id], onDelete: Cascade)
  interview          Interview @relation(fields: [interviewId], references: [id], onDelete: Cascade)

  @@map("interview_evaluation")
}

model InterviewAnalytics {
  id                  String    @id @default(cuid())
  interviewId         String
  speechClarity       Float?
  speechPace          Float?
  fillerWords         Int?
  confidence          Float?
  eyeContact          Float?
  facialExpressions   String?
  bodyLanguage        String?
  responseTime        Float?
  accuracyScore       Float?
  problemSolvingScore Float?
  attention           Float?
  participation       Float?
  analysisData        String?
  createdAt           DateTime  @default(now())
  interview           Interview @relation(fields: [interviewId], references: [id], onDelete: Cascade)

  @@map("interview_analytics")
}

model CandidateProfile {
  id               String   @id @default(cuid())
  userId           String   @unique
  resume           String?
  coverLetter      String?
  portfolio        String?
  linkedIn         String?
  github           String?
  skills           String[]
  experience       String?
  education        String?
  certifications   String[]
  jobTitle         String?
  expectedSalary   String?
  location         String?
  remote           Boolean  @default(false)
  skillAssessments String?
  personalityType  String?
  careerGoals      String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  user             User     @relation("CandidateProfile", fields: [userId], references: [id], onDelete: Cascade)

  @@map("candidate_profile")
}

model AIMockSession {
  id               String          @id @default(cuid())
  userId           String
  sessionType      String
  aiPersonality    String
  difficultyLevel  String
  topics           String[]
  duration         Int
  conversationLog  String?
  feedback         String?
  improvementAreas String[]
  overallScore     Float?
  specificScores   String?
  startedAt        DateTime?
  completedAt      DateTime?
  createdAt        DateTime        @default(now())
  user             User            @relation("AIMockSessions", fields: [userId], references: [id], onDelete: Cascade)
  mockQuestions    MockQuestion[]

  @@map("ai_mock_session")
}

model MockQuestion {
  id              String        @id
  sessionId       String
  questionText    String
  questionType    String
  idealAnswer     String?
  userAnswer      String?
  timeSpent       Int?
  score           Float?
  feedback        String?
  strengths       String[]
  weaknesses      String[]
  suggestions     String[]
  order           Int
  createdAt       DateTime      @default(now())
  aiMockSession   AIMockSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
}

model LinkedInImportSession {
  id        String   @id @default(cuid())
  sessionId String   @unique @default(cuid()) // Cryptographic session ID for security
  data      Json     // Stores complete CVData as JSON
  expiresAt DateTime // Session expiration time
  createdAt DateTime @default(now())
  retrievedAt DateTime? // Track if/when it was retrieved
  
  @@index([expiresAt])
  @@index([sessionId])
  @@map("linkedin_import_session")
}
